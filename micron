#! /usr/bin/env python

'''
Schedule jobs
'''

import sys
import os.path
import argparse
import time
from datetime import datetime
import threading
import shlex, subprocess
import parsedatetime.parsedatetime
import yaml

FMT = '%d %b %Y %H:%M:%S'

# TODO Logging
# TODO Notification windows
# TODO D-Bus events

def dump(runs, directory):
    with open(directory + '/runs.yaml', 'w') as fhl:
        yaml.safe_dump(runs, fhl, default_flow_style=False)

def run(name, job):
    print "running %s..." % name
    try:
        cwd = os.path.expanduser(job['cwd'])
    except KeyError:
        cwd = None
    subprocess.check_call(job['command'], shell=True, cwd=cwd)

def main():
    # Arguments
    parser = argparse.ArgumentParser('Schedule jobs.')
    parser.add_argument('-d', '--directory', type=os.path.expanduser,
                        default='~/.micron')
    args = parser.parse_args()

    # Create directory
    try:
        os.mkdir(args.directory)
    except OSError:
        pass

    # Create datetime parser
    parser = parsedatetime.parsedatetime.Calendar()

    # Create thread list
    threads = {}

    # Loop
    try:
        while True:
            # Load jobs from file
            try:
                with open(args.directory + '/jobs.yaml') as fhl:
                    jobs = yaml.load(fhl, Loader=yaml.BaseLoader)
            except IOError, exc:
                print >> sys.stderr, exc
                return 1

            # Load last runs
            try:
                with open(args.directory + '/runs.yaml') as fhl:
                    runs = yaml.load(fhl, Loader=yaml.BaseLoader)
            except IOError:
                runs = {}

            # Run jobs when applicable
            for job in jobs:
                now = datetime.now()

                # When would the next run be?
                try:
                    nextrun = parser.parse('%s from %s' % (jobs[job]['every'],
                                           runs[job]['end']))[0]
                    nextrun = time.mktime(nextrun)
                    del runs[job]['end']
                    runs[job]['start'] = now.strftime(FMT)
                except KeyError:
                    nextrun = 0
                    runs[job] = {'start': now.strftime(FMT)}
                except TypeError: # When runs is None
                    nextrun = 0
                    runs = {job: {'start': now.strftime(FMT)}}

                # Is the job running?
                try:
                    running = threads[job].is_alive()
                except KeyError:
                    running = False

                # Run the job?
                if not running and now > datetime.fromtimestamp(nextrun):
                    # Reset job run
                    dump(runs, args.directory)

                    # Run job
                    threads[job] = threading.Thread(target=run,
                                                    args=(job, jobs[job]))
                    threads[job].start()

                    # Report
                    try:
                        runs[job]['end'] = datetime.now().strftime(FMT)
                    except KeyError:
                        runs[job] = {'end': datetime.now().strftime(FMT)}
                    dump(runs, args.directory)

            time.sleep(2)
    except KeyboardInterrupt:
        pass

if __name__ == '__main__':
    sys.exit(main())
